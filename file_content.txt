import React, { useState, useEffect, useRef } from 'react';
import { MessageSquare, AlertCircle, X, Loader2, Send, ChevronLeft, ChevronRight } from 'lucide-react';
import { ImageUploader } from '../components/ImageUploader';
import { ChartGenerator } from '../components/ChartGenerator';
import { UploadConfirmationModal } from '../components/UploadConfirmationModal';
import { AVAILABLE_MODELS, analyzeImage, type ModelId, sendChatMessage } from '../services/openrouter';
import Markdown from 'react-markdown';
import { useTypingEffect } from '../hooks/useTypingEffect';
import { formatTimeframe } from '../utils/formatters';
import { auth, database } from '../lib/firebase';
import { onAuthStateChanged } from 'firebase/auth';
import { saveChatAnalysis, uploadChartImage, getUserAnalyses } from '../lib/firebase';
import styles from './AIAnalysisChat.module.css';
import { useAnalysisContext } from '../context/AnalysisContext';
import { useLocation, useNavigate } from 'react-router-dom';

const AnalysisType = {
  Technical: 'Technical',
  Fundamental: 'Fundamental',
  Combined: 'Combined'
} as const;

type AnalysisTypeKey = keyof typeof AnalysisType;

interface Message {
  role: 'user' | 'assistant';
  content: string;
  isTyping?: boolean;
}

const extractConfidenceLevel = (text: string): number | null => {
  // First try to match explicit percentage
  const percentMatch = text.match(/confidence(?:\s+level)?[:\s]+(\d+)%/i);
  if (percentMatch) {
    return parseInt(percentMatch[1]);
  }

  // If no explicit percentage, check for descriptive terms
  const confidenceLevelText = text.toLowerCase();
  if (confidenceLevelText.includes('confidence level:') || confidenceLevelText.includes('confidence:')) {
    if (confidenceLevelText.includes('very high') || confidenceLevelText.includes('strong')) return 90;
    if (confidenceLevelText.includes('high')) return 80;
    if (confidenceLevelText.includes('moderate')) return 65;
    if (confidenceLevelText.includes('low')) return 40;
    if (confidenceLevelText.includes('very low')) return 25;
  }
  return null;
};

const ConfidenceBar = ({ percentage, showLabel = true }: { percentage: number, showLabel?: boolean }) => {
  const getColorClass = (value: number) => {
    if (value >= 80) return 'bg-green-500';
    if (value >= 60) return 'bg-yellow-500';
    return 'bg-red-500';
  };

  return (
    <div className="mt-2 w-full">
      <div className="flex items-center gap-2">
        <div className="flex-1 bg-gray-700 rounded-full h-2.5 overflow-hidden">
          <div 
            className={`h-full rounded-full ${getColorClass(percentage)} transition-all duration-500`}
            style={{ width: `${percentage}%` }}
          />
        </div>
        {showLabel && (
          <span className="text-sm font-medium text-gray-300 min-w-[3rem]">
            {percentage}%
          </span>
        )}
      </div>
    </div>
  );
};

const formatAnalysisOutput = (content: string) => {
  if (!content) return null;

  // Extract all data points using helper functions
  const symbol = extractSymbol(content);
  const price = extractPrice(content);
  const supportLevels = extractSupportLevels(content);
  const resistanceLevels = extractResistanceLevels(content);
  const priceMovement = extractPriceMovement(content);
  const rsi = extractRSI(content);
  const rsiSignal = extractRSISignal(content);
  const rsiAnalysis = extractRSIAnalysis(content);
  const macdValues = extractMACDValues(content);
  const macdSignal = extractMACDSignal(content);
  const macdAnalysis = extractMACDAnalysis(content);
  const bollingerBands = extractBollingerBands(content);
  const bollingerSignal = extractBollingerSignal(content);
  const bollingerAnalysis = extractBollingerAnalysis(content);
  const stochastic = extractStochastic(content);
  const stochasticSignal = extractStochasticSignal(content);
  const stochasticAnalysis = extractStochasticAnalysis(content);
  const otherIndicator = extractOtherIndicator(content);
  const otherIndicatorName = extractOtherIndicatorName(content);
  const otherIndicatorSignal = extractOtherIndicatorSignal(content);
  const otherIndicatorAnalysis = extractOtherIndicatorAnalysis(content);
  const tradingAction = extractTradingAction(content);
  const tradingAnalysis = extractTradingAnalysis(content);

  // Check for phrases to hide
  if (supportLevels.includes("No clear reversal or continuation patterns observed") ||
      supportLevels.includes("N/A") ||
      supportLevels.includes("not visible") ||
      supportLevels.includes("No clear chart patterns identified")) {
    return null; // Skip rendering this section
  }

  // Calculate confidence level based on signals
  const signals = [rsiSignal, macdSignal, bollingerSignal, stochasticSignal, otherIndicatorSignal].filter(signal => signal !== 'Neutral');
  const confidenceLevel = Math.min(100, (signals.length / 5) * 100);

  return (
    <div className={styles.analysisOutput}>
      {/* Main Header */}
      <h2 className={styles.mainHeader}>ðŸ¤– AI ANALYSIS</h2>
      
      {/* Technical Analysis Section */}
      <div className={styles.section}>
        <h3 className={`${styles.sectionHeader} ${styles.blueHeader}`} data-number="1">Technical Aspects</h3>
        
        {/* Price Action Analysis */}
        <div className={styles.contentPanel}>
          <div className={styles.subHeader}>Price Action Analysis</div>
          <div className={styles.space4}>
            <p className={styles.infoText}>
              <span className={styles.label}>Symbol:</span>
              <span className={styles.value}>{symbol}</span>
            </p>
            <p className={styles.infoText}>
              <span className={styles.label}>Current Price:</span>
              <span className={styles.value}>{price}</span>
            </p>
            <p className={styles.infoText}>
              <span className={styles.label}>Support Levels:</span>
              <span className={styles.value}>{supportLevels}</span>
            </p>
            <p className={styles.infoText}>
              <span className={styles.label}>Resistance Levels:</span>
              <span className={styles.value}>{resistanceLevels}</span>
            </p>
            <p className={styles.infoText}>
              <span className={styles.label}>Price Movement:</span>
              <span className={styles.value}>{priceMovement}</span>
            </p>
          </div>
        </div>

        {/* Technical Indicators */}
        {(rsi && rsi !== 'N/A') || 
         (macdValues && macdValues !== 'N/A') || 
         (bollingerBands && bollingerBands !== 'N/A') || 
         (stochastic && stochastic !== 'N/A') || 
         (otherIndicator && otherIndicator !== 'N/A') ? (
        <div className={styles.contentPanel}>
          <div className={styles.subHeader}>Technical Indicators</div>
          <div className={styles.space4}>
            {/* RSI Analysis */}
            {rsi && rsi !== 'N/A' && (
            <div>
              <div className={styles.subHeader}>RSI Analysis</div>
              <p className={styles.infoText}>
                <span className={styles.label}>RSI Value:</span>
                <span className={styles.value}>{rsi}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Signal:</span>
                <span className={`${styles.signalValue} ${
                  rsiSignal === 'Overbought' ? styles.bearish :
                  rsiSignal === 'Oversold' ? styles.bullish :
                  styles.neutral
                }`}>{rsiSignal}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Analysis:</span>
                <span className={styles.value}>{rsiAnalysis}</span>
              </p>
            </div>
            )}

            {/* MACD Analysis */}
            {macdValues && macdValues !== 'N/A' && (
            <div>
              <div className={styles.subHeader}>MACD Analysis</div>
              <p className={styles.infoText}>
                <span className={styles.label}>Values:</span>
                <span className={styles.value}>{macdValues}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Signal:</span>
                <span className={`${styles.signalValue} ${
                  macdSignal === 'Bullish' ? styles.bullish :
                  macdSignal === 'Bearish' ? styles.bearish :
                  styles.neutral
                }`}>{macdSignal}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Analysis:</span>
                <span className={styles.value}>{macdAnalysis}</span>
              </p>
            </div>
            )}
            
            {/* Bollinger Bands Analysis */}
            {bollingerBands && bollingerBands !== 'N/A' && (
            <div>
              <div className={styles.subHeader}>Bollinger Bands Analysis</div>
              <p className={styles.infoText}>
                <span className={styles.label}>Values:</span>
                <span className={styles.value}>{bollingerBands}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Signal:</span>
                <span className={`${styles.signalValue} ${
                  bollingerSignal === 'Bullish' ? styles.bullish :
                  bollingerSignal === 'Bearish' ? styles.bearish :
                  styles.neutral
                }`}>{bollingerSignal}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Analysis:</span>
                <span className={styles.value}>{bollingerAnalysis}</span>
              </p>
            </div>
            )}
            
            {/* Stochastic Analysis */}
            {stochastic && stochastic !== 'N/A' && (
            <div>
              <div className={styles.subHeader}>Stochastic Oscillator Analysis</div>
              <p className={styles.infoText}>
                <span className={styles.label}>Values:</span>
                <span className={styles.value}>{stochastic}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Signal:</span>
                <span className={`${styles.signalValue} ${
                  stochasticSignal === 'Bullish' ? styles.bullish :
                  stochasticSignal === 'Bearish' ? styles.bearish :
                  styles.neutral
                }`}>{stochasticSignal}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Analysis:</span>
                <span className={styles.value}>{stochasticAnalysis}</span>
              </p>
            </div>
            )}
            
            {/* Other Technical Indicators */}
            {otherIndicator && otherIndicator !== 'N/A' && (
            <div>
              <div className={styles.subHeader}>{otherIndicatorName} Analysis</div>
              <p className={styles.infoText}>
                <span className={styles.label}>Values:</span>
                <span className={styles.value}>{otherIndicator}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Signal:</span>
                <span className={`${styles.signalValue} ${
                  otherIndicatorSignal === 'Bullish' ? styles.bullish :
                  otherIndicatorSignal === 'Bearish' ? styles.bearish :
                  styles.neutral
                }`}>{otherIndicatorSignal}</span>
              </p>
              <p className={styles.infoText}>
                <span className={styles.label}>Analysis:</span>
                <span className={styles.value}>{otherIndicatorAnalysis}</span>
              </p>
            </div>
            )}
          </div>
        ) : null}
      </div>

      {/* Risk Management Section */}
      <div className={styles.section}>
        <h3 className={`${styles.sectionHeader} ${styles.purpleHeader}`} data-number="2">Risk Management</h3>
        
        {/* Risk Assessment */}
        <div className={styles.contentPanel}>
          <div className={styles.subHeader}>Risk Assessment</div>
          <div className={styles.space4}>
            <p className={styles.infoText}>
              <span className={styles.label}>Market Volatility:</span>
              <span className={styles.value}>{/* Add volatility data */}</span>
            </p>
            <p className={styles.infoText}>
              <span className={styles.label}>Risk Level:</span>
              <span className={styles.value}>{/* Add risk level */}</span>
            </p>
          </div>
        </div>

        {/* Position Sizing */}
        <div className={styles.contentPanel}>
          <div className={styles.subHeader}>Position Sizing</div>
          <div className={styles.space4}>
            <p className={styles.infoText}>
              <span className={styles.label}>Recommended Size:</span>
              <span className={styles.value}>{/* Add position size */}</span>
            </p>
            <p className={styles.infoText}>
              <span className={styles.label}>Risk Per Trade:</span>
              <span className={styles.value}>{/* Add risk percentage */}</span>
            </p>
          </div>
        </div>
      </div>

      {/* Trading Action and Analysis */}
      <div className={styles.section}>
        <h3 className={`${styles.sectionHeader} ${styles.greenHeader}`}>Entry/Exit Strategies</h3>
        <div className={styles.contentPanel}>
          <p className={styles.infoText}>
            <span className={styles.label}>Recommended Action:</span>
            <span className={`${styles.signalValue} ${
              tradingAction?.toLowerCase() === 'buy' ? styles.bullish :
              tradingAction?.toLowerCase() === 'sell' ? styles.bearish :
              styles.neutral
            }`}>{tradingAction}</span>
          </p>
          <p className={styles.infoText}>
            <span className={styles.label}>Analysis:</span>
            <span className={styles.value}>{tradingAnalysis}</span>
          </p>
        </div>
      </div>
    </div>
  );
};

// Helper functions to extract data from analysis content
const extractFromContent = (content: string, pattern: RegExp): string => {
  const match = content.match(pattern);
  return match ? match[1].trim() : 'N/A';
};

const extractSymbol = (content: string): string => {
  return extractFromContent(content, /Symbol:?\s*([A-Z/]+)/i) || 'NZDUSD';
};

const extractPrice = (content: string): string => {
  return extractFromContent(content, /Current Price:?\s*([\d.]+)/i);
};

const extractSupportLevels = (content: string): string => {
  return extractFromContent(content, /Support Levels?:?\s*([\d., ]+)/i);
};

const extractResistanceLevels = (content: string): string => {
  return extractFromContent(content, /Resistance Levels?:?\s*([\d., ]+)/i);
};

const extractPriceMovement = (content: string): string => {
  return extractFromContent(content, /Price Movement:?\s*([^.]+\.)/i);
};

const extractRSI = (content: string): string => {
  // First check if the RSI section exists in the content
  if (!content.toLowerCase().includes('rsi indicator') && 
      !content.toLowerCase().includes('rsi analysis')) {
    return 'N/A';
  }
  // If RSI is mentioned but with "Not visible" or similar phrases, return N/A
  if (content.toLowerCase().includes('rsi') && 
      (content.toLowerCase().includes('not visible') || 
       content.toLowerCase().includes('not applicable') ||
       content.toLowerCase().includes('n/a'))) {
    return 'N/A';
  }
  return extractFromContent(content, /RSI:?\s*([\d.]+)/i);
};

const extractRSISignal = (content: string): string => {
  const rsi = parseFloat(extractRSI(content));
  if (isNaN(rsi)) return 'Neutral';
  if (rsi > 70) return 'Overbought';
  if (rsi < 30) return 'Oversold';
  return 'Neutral';
};

const extractRSIAnalysis = (content: string): string => {
  return extractFromContent(content, /RSI Analysis:?\s*([^.]+\.)/i);
};

const extractMACDValues = (content: string): string => {
  // First check if the MACD section exists in the content
  if (!content.toLowerCase().includes('macd indicator') && 
      !content.toLowerCase().includes('macd analysis')) {
    return 'N/A';
  }
  // If MACD is mentioned but with "Not visible" or similar phrases, return N/A
  if (content.toLowerCase().includes('macd') && 
      (content.toLowerCase().includes('not visible') || 
       content.toLowerCase().includes('not applicable') ||
       content.toLowerCase().includes('n/a'))) {
    return 'N/A';
  }
  return extractFromContent(content, /MACD:?\s*([^.]+\.)/i);
};

const extractMACDSignal = (content: string): string => {
  const macdContent = content.toLowerCase();
  if (macdContent.includes('bullish crossover') || macdContent.includes('bullish signal')) return 'Bullish';
  if (macdContent.includes('bearish crossover') || macdContent.includes('bearish signal')) return 'Bearish';
  return 'Neutral';
};

const extractMACDAnalysis = (content: string): string => {
  return extractFromContent(content, /MACD Analysis:?\s*([^.]+\.)/i);
};

const extractBollingerBands = (content: string): string => {
  // First check if the Bollinger Bands section exists in the content
  if (!content.toLowerCase().includes('bollinger bands indicator') && 
      !content.toLowerCase().includes('bollinger bands analysis')) {
    return 'N/A';
  }
  // If Bollinger Bands is mentioned but with "Not visible" or similar phrases, return N/A
  if (content.toLowerCase().includes('bollinger bands') && 
      (content.toLowerCase().includes('not visible') || 
       content.toLowerCase().includes('not applicable') ||
       content.toLowerCase().includes('n/a'))) {
    return 'N/A';
  }
  return extractFromContent(content, /Bollinger Bands:?\s*([^.]+\.)/i);
};

const extractBollingerSignal = (content: string): string => {
  const bollingerContent = content.toLowerCase();
  if (bollingerContent.includes('bullish signal') || bollingerContent.includes('buy signal')) return 'Bullish';
  if (bollingerContent.includes('bearish signal') || bollingerContent.includes('sell signal')) return 'Bearish';
  return 'Neutral';
};

const extractBollingerAnalysis = (content: string): string => {
  return extractFromContent(content, /Bollinger Bands Analysis:?\s*([^.]+\.)/i);
};

const extractStochastic = (content: string): string => {
  // First check if the Stochastic Oscillator section exists in the content
  if (!content.toLowerCase().includes('stochastic oscillator indicator') && 
      !content.toLowerCase().includes('stochastic oscillator analysis')) {
    return 'N/A';
  }
  // If Stochastic Oscillator is mentioned but with "Not visible" or similar phrases, return N/A
  if (content.toLowerCase().includes('stochastic oscillator') && 
      (content.toLowerCase().includes('not visible') || 
       content.toLowerCase().includes('not applicable') ||
       content.toLowerCase().includes('n/a'))) {
    return 'N/A';
  }
  return extractFromContent(content, /Stochastic Oscillator:?\s*([^.]+\.)/i);
};

const extractStochasticSignal = (content: string): string => {
  const stochasticContent = content.toLowerCase();
  if (stochasticContent.includes('bullish signal') || stochasticContent.includes('buy signal')) return 'Bullish';
  if (stochasticContent.includes('bearish signal') || stochasticContent.includes('sell signal')) return 'Bearish';
  return 'Neutral';
};

const extractStochasticAnalysis = (content: string): string => {
  return extractFromContent(content, /Stochastic Oscillator Analysis:?\s*([^.]+\.)/i);
};

const extractOtherIndicator = (content: string): string => {
  // First check if the Other Indicator section exists in the content
  if (!content.toLowerCase().includes('other indicator') && 
      !content.toLowerCase().includes('other analysis')) {
    return 'N/A';
  }
  // If Other Indicator is mentioned but with "Not visible" or similar phrases, return N/A
  if (content.toLowerCase().includes('other indicator') && 
      (content.toLowerCase().includes('not visible') || 
       content.toLowerCase().includes('not applicable') ||
       content.toLowerCase().includes('n/a'))) {
    return 'N/A';
  }
  return extractFromContent(content, /Other Indicator:?\s*([^.]+\.)/i);
};

const extractOtherIndicatorName = (content: string): string => {
  return extractFromContent(content, /Other Indicator Name:?\s*([^.]+\.)/i);
};

const extractOtherIndicatorSignal = (content: string): string => {
  const otherIndicatorContent = content.toLowerCase();
  if (otherIndicatorContent.includes('bullish signal') || otherIndicatorContent.includes('buy signal')) return 'Bullish';
  if (otherIndicatorContent.includes('bearish signal') || otherIndicatorContent.includes('sell signal')) return 'Bearish';
  return 'Neutral';
};

const extractOtherIndicatorAnalysis = (content: string): string => {
  return extractFromContent(content, /Other Indicator Analysis:?\s*([^.]+\.)/i);
};

const extractTradingAction = (content: string): string => {
  return extractFromContent(content, /Trading Action:?\s*(\w+)/i);
};

const extractTradingAnalysis = (content: string): string => {
  return extractFromContent(content, /Trading Analysis:?\s*([^.]+\.)/i);
};

const ChatMessage = ({ message, isLoading, isCurrent }: { message: Message, isLoading: boolean, isCurrent: boolean }) => (
  <div className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}>
    <div className={`rounded-lg p-2.5 ${message.role === 'user' ? 'bg-blue-600' : 'bg-gray-800'} max-w-[80%]`}>
      <Markdown className={`${styles.markdownContent} text-sm ${message.role === 'user' ? 'text-white' : 'text-gray-300'}`}>
        {message.content}
      </Markdown>
      {isLoading && isCurrent && (
        <div className="flex items-center text-blue-400 mt-2">
          <span className="mr-2">Analyzing...</span>
          <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
        </div>
      )}
    </div>
  </div>
);

export function AIAnalysisChat() {
  const location = useLocation();
  const navigate = useNavigate();

  const { 
    image, 
    setImage, 
    analysis, 
    setAnalysis, 
    timeframe, 
    setTimeframe,
    chartPreviews,
    setChartPreviews,
    initialMessage
  } = useAnalysisContext();

  const { displayedText, isTyping } = useTypingEffect(initialMessage, { typingSpeed: 25 });
  const [selectedModel, setSelectedModel] = useState<ModelId>(AVAILABLE_MODELS[0].id);
  
  // Track model-specific conversations and analysis
  const [modelConversations, setModelConversations] = useState<Record<string, {
    messages: Message[];
    analysis: string;
    chartPreviews: string[];
  }>>({});

  const premiumModels = AVAILABLE_MODELS.filter(model => model.premium);
  const nonPremiumModels = AVAILABLE_MODELS.filter(model => !model.premium);

  const [analysisType, setAnalysisType] = useState<typeof AnalysisType[AnalysisTypeKey]>(AnalysisType.Technical);
  const [isGeneratingChart, setIsGeneratingChart] = useState(false);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showUploadPrompt, setShowUploadPrompt] = useState(false);
  const [showUploader, setShowUploader] = useState(false);
  const [pendingImages, setPendingImages] = useState<string[]>(chartPreviews);
  const [selectedPreviewUrl, setSelectedPreviewUrl] = useState<string | null>(null);
  const [showChartGenerator, setShowChartGenerator] = useState(false);
  const [selectedOption, setSelectedOption] = useState('Upload Chart');
  const [totalCharts, setTotalCharts] = useState(0);
  const [currentChart, setCurrentChart] = useState(0);
  const [analysisResults, setAnalysisResults] = useState<{ symbol: string; timeframe: string; analysis: string }[]>([]);
  const [currentAnalysisIndex, setCurrentAnalysisIndex] = useState(0);
  const [historyId, setHistoryId] = useState<string | null>(null);
  const [modelHistoryIds, setModelHistoryIds] = useState<Record<string, string>>({});

  const [chatHistory, setChatHistory] = useState<Message[]>([]);
  
  useEffect(() => {
    if (historyId) {
      sessionStorage.setItem('currentHistoryId', historyId);
      console.log('History ID saved to sessionStorage:', historyId);
      
      // Also update the model-specific history ID mapping
      setModelHistoryIds(prev => ({
        ...prev,
        [selectedModel]: historyId
      }));
    }
  }, [historyId, selectedModel]);

  const resetHistoryId = () => {
    setHistoryId(null);
    sessionStorage.removeItem('currentHistoryId');
    // Also reset model-specific history IDs and conversations
    setModelHistoryIds({});
    setModelConversations({});
    console.log('History ID reset for new conversation');
  };

  useEffect(() => {
    setSelectedOption('Upload Chart');
    setShowUploader(true);
    setShowChartGenerator(false);
  }, []);

  useEffect(() => {
    setPendingImages(chartPreviews);
  }, [chartPreviews]);

  const [messages, setMessages] = useState<Message[]>([{
    role: 'assistant',
    content: initialMessage
  }]);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    setMessages([{
      role: 'assistant',
      content: initialMessage
    }]);
  }, [initialMessage]);

  // Add useEffect to handle auth state changes
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      if (!user) {
        // Only clear if user logs out
        setImage(null);
        setAnalysis(null);
        setTimeframe('');
        setMessages([{
          role: 'assistant',
          content: initialMessage
        }]);
      }
    });

    return () => unsubscribe();
  }, []);

  // Add useEffect to load saved state on component mount
  useEffect(() => {
    if (!auth.currentUser) return; // Don't load if not authenticated
    
    // Only load messages from localStorage
    const savedMessages = localStorage.getItem('messages');
    if (savedMessages) {
      setMessages(JSON.parse(savedMessages));
    }
  }, []);

  // Add useEffect to save state when it changes
  useEffect(() => {
    if (messages.length > 0) {
      localStorage.setItem('messages', JSON.stringify(messages));
    }
  }, [messages]);

  // Add useEffect to load stored previews
  useEffect(() => {
    const storedPreviews = sessionStorage.getItem('chartPreviews');
    if (storedPreviews) {
      const previews = JSON.parse(storedPreviews);
      setChartPreviews(previews);
      setPendingImages(previews);
    }
  }, []);

  // Add useEffect to clear messages on page refresh
  useEffect(() => {
    const clearChat = () => {
      setMessages([{
        role: 'assistant',
        content: initialMessage
      }]);
    };

    window.addEventListener('beforeunload', clearChat);
    
    return () => {
      window.removeEventListener('beforeunload', clearChat);
    };
  }, [initialMessage]);

  // Add useEffect to handle location state and clean page loading
  useEffect(() => {
    // Check if we're starting a new session
    if (location.state?.newSession) {
      console.log('Starting new Analysis session');
      
      // Reset all state variables to their initial values
      setMessages([{
        role: 'assistant',
        content: initialMessage
      }]);
      setSelectedModel(AVAILABLE_MODELS[0].id);
      setAnalysisType(AnalysisType.Technical);
      setImage(null);
      setPendingImages([]);
      setShowUploader(true);
      setShowUploadPrompt(false);
      setIsLoading(false);
      setError(null);
      setIsGeneratingChart(false);
      setInputMessage('');
      
      // Clear the location state to prevent re-initializing on page refresh
      window.history.replaceState({}, document.title);
    }
  }, [location.state, initialMessage]);

  // Separate effect to handle analysis loading to avoid dependency loops
  useEffect(() => {
    if (analysis && messages.length === 1 && messages[0].role === 'assistant' && 
        !messages.some(msg => msg.content === analysis)) {
      console.log('Analysis loaded and displayed in analysis section only');
      // Intentionally not modifying messages array
    }
  }, [analysis]);

  const [inputMessage, setInputMessage] = useState('');

  const blobToBase64 = (blob: Blob): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (typeof reader.result === 'string') {
          resolve(reader.result);
        }
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  };

  const urlToBase64 = async (url: string): Promise<string> => {
    if (url.startsWith('data:')) return url; // Already base64
    try {
      const response = await fetch(url);
      const blob = await response.blob();
      return blobToBase64(blob);
    } catch (error) {
      throw new Error('Failed to convert URL to base64');
    }
  };

  const handleImageSelect = async (imageUrl: string) => {
    setError(null);
    
    try {
      // Store base64 for display/persistence but keep original URL for AI
      const base64Image = await urlToBase64(imageUrl);
      setImage(base64Image);
      
      // Store the original URL for later analysis and preview
      setPendingImages(prev => [...prev, imageUrl]);
      
      // Show upload prompt without analyzing
      setShowUploadPrompt(true);

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to process image';
      setError(errorMessage);
      
      // Clear all data regardless of error type
      setImage(null);
      setAnalysis(null);
      setError(null);
      setPendingImages([]);
      
      // Reset messages to initial state
      setMessages([{
        role: 'assistant',
        content: initialMessage
      }]);
    }
  };

  const handleChartGenerated = async (chartUrl: string) => {
    setIsGeneratingChart(true);
    setError(null);

    try {
      const base64Image = await urlToBase64(chartUrl);
      setImage(base64Image);
      
      // Update both local state and context
      const updatedImages = [...pendingImages, base64Image];
      setPendingImages(updatedImages);
      setChartPreviews(updatedImages);
      setShowUploadPrompt(true);

      // Extract timeframe from the URL for context
      const params = new URLSearchParams(chartUrl.split('?')[1]);
      const interval = params.get('interval');
      if (interval) {
        setTimeframe(interval);
      }

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to generate chart');
      setImage(null);
      setPendingImages([]);
      setChartPreviews([]);
    } finally {
      setIsGeneratingChart(false);
    }
  };

  const handleRemoveImage = (index: number) => {
    const updatedImages = [...pendingImages];
    updatedImages.splice(index, 1);
    setPendingImages(updatedImages);
    setChartPreviews(updatedImages);
    sessionStorage.setItem('chartPreviews', JSON.stringify(updatedImages));

    if (updatedImages.length === 0) {
      setShowUploadPrompt(false);
      setShowUploader(true);
    }
  };

  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleUploadMore = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  const handleCloseUpload = () => {
    setShowUploader(false);
    setShowChartGenerator(false);
    setShowUploadPrompt(false);
  };

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files) return;

    try {
      const newImages: string[] = [];

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (!file.type.startsWith('image/')) {
          console.error('Invalid file type:', file.type);
          continue;
        }

        const base64 = await convertToBase64(file);
        newImages.push(base64);
      }

      // Update both context and session storage
      const updatedPreviews = [...chartPreviews, ...newImages];
      setChartPreviews(updatedPreviews);
      setPendingImages(updatedPreviews);
      sessionStorage.setItem('chartPreviews', JSON.stringify(updatedPreviews));

      setShowUploadPrompt(true);
    } catch (err) {
      console.error('Error processing files:', err);
      handleError('Failed to process image files');
    }
  };

  const handleDrop = async (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(false);

    const files = event.dataTransfer.files;
    if (!files) return;

    try {
      const newImages: string[] = [];

      for (let i = 0; i <files.length; i++) {
        const file = files[i];
        if (!file.type.startsWith('image/')) {
          console.error('Invalid file type:', file.type);
          continue;
        }

        const base64 = await convertToBase64(file);
        newImages.push(base64);
      }

      // Update both context and session storage
      const updatedPreviews = [...chartPreviews, ...newImages];
      setChartPreviews(updatedPreviews);
      setPendingImages(updatedPreviews);
      sessionStorage.setItem('chartPreviews', JSON.stringify(updatedPreviews));

      setShowUploadPrompt(true);
    } catch (err) {
      console.error('Error processing files:', err);
      handleError('Failed to process image files');
    }
  };

  const convertToBase64 = async (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (typeof reader.result === 'string') {
          resolve(reader.result);
        }
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  };

  const handleFinishUploading = async () => {
    console.log('Starting upload and analysis process...');
    setShowUploadPrompt(false);
    setIsAnalyzing(true);
    setTotalCharts(chartPreviews.length);
    setCurrentChart(0);

    try {
      console.log(`Starting analysis of ${chartPreviews.length} charts...`);
      
      const analysisBySymbol: Record<string, { symbol: string; timeframes: string[]; analyses: string[] }> = {};

      // Analyze all charts
      for (let i = 0; i < chartPreviews.length; i++) {
        console.log(`Analyzing chart ${i + 1} of ${chartPreviews.length}`);
        setCurrentChart(i + 1);
        const imageUrl = chartPreviews[i];
        console.log('Starting image analysis...');
        const result = await analyzeImage(imageUrl, selectedModel);
        console.log('Image analysis complete. Result:', result.substring(0, 100) + '...');

        // Extract symbol and timeframe using regex
        const symbolMatch = result.match(/Symbol:\s*([^\n|]+)/i);
        const timeframeMatch = result.match(/Timeframe:\s*([^\n|]+)/i);

        const symbol = symbolMatch?.[1]?.trim() || 'Unknown';
        const timeframe = timeframeMatch?.[1]?.trim() || 'Unknown';

        // Remove symbol and timeframe lines from the analysis
        const analysisWithoutHeader = result
          .replace(/Symbol:.*\n?/i, '')
          .replace(/Timeframe:.*\n?/i, '')
          .trim();

        // Group by symbol
        if (!analysisBySymbol[symbol]) {
          analysisBySymbol[symbol] = {
            symbol,
            timeframes: [],
            analyses: []
          };
        }
        
        analysisBySymbol[symbol].timeframes.push(timeframe);
        analysisBySymbol[symbol].analyses.push(analysisWithoutHeader);
      }

      // Process each symbol group
      const finalAnalysisResults: { symbol: string; timeframe: string; analysis: string }[] = [];
      
      for (const symbol in analysisBySymbol) {
        const { timeframes, analyses } = analysisBySymbol[symbol];
        
        // If there are multiple analyses for the same symbol, combine them
        let combinedAnalysis = '';
        for (const analysis of analyses) {
          combinedAnalysis += (combinedAnalysis ? '\n\n' : '') + analysis;
        }
        
        // If we have multiple analyses for the same symbol, request a combined analysis
        if (analyses.length > 1) {
          console.log(`Requesting combined analysis for symbol: ${symbol}...`);
          const combinedPrompt = `Please provide a combined market analysis for the symbol: ${symbol} across timeframes: ${timeframes.join(', ')}. Here are the individual analyses to combine:\n\n${combinedAnalysis}`;
          
          const combinedResult = await analyzeImage(chartPreviews[0], selectedModel, combinedPrompt);
          console.log('Combined analysis received:', combinedResult.substring(0, 100) + '...');
          combinedAnalysis = combinedResult
            .replace(/Symbol:.*\n?/i, '')
            .replace(/Timeframe:.*\n?/i, '')
            .trim();
        }

        // Format the final analysis with symbol and timeframes
        const finalAnalysis = [
          `Symbol: ${symbol}`,
          '', // This empty string creates a new line
          `Timeframe: ${timeframes.join(' | ')}`,
          '',
          combinedAnalysis
        ].join('\n');

        finalAnalysisResults.push({
          symbol,
          timeframe: timeframes.join(' | '),
          analysis: finalAnalysis
        });
      }

      // Set the analysis results
      setAnalysisResults(finalAnalysisResults);
      setCurrentAnalysisIndex(0);
      
      // Set the current analysis for display
      if (finalAnalysisResults.length > 0) {
        setAnalysis(finalAnalysisResults[0].analysis);
      }
      
      console.log('All charts analyzed successfully');

      // Upload analyzed charts to Firebase if user is authenticated
      const user = auth.currentUser;
      console.log('ðŸ‘¤ User authentication status:', { 
        isAuthenticated: !!user,
        userId: user?.uid 
      });

      const firebaseUrls: string[] = [];
      if (user) {
        console.log('ðŸš€ Starting Firebase upload for analyzed charts...');
        for (let i = 0; i < chartPreviews.length; i++) {
          try {
            // Convert base64 to blob
            console.log(`ðŸ“· Processing chart ${i + 1}/${chartPreviews.length}...`);
            const response = await fetch(chartPreviews[i]);
            const blob = await response.blob();
            console.log('âœ… Blob created:', { 
              size: blob.size, 
              type: blob.type 
            });

            // Upload to Firebase
            const imageUrl = await uploadChartImage(user.uid, blob);
            console.log('âœ… Chart uploaded successfully:', {
              url: imageUrl.substring(0, 50) + '...',
              chartIndex: i + 1
            });
            firebaseUrls.push(imageUrl);
          } catch (error) {
            console.error('âŒ Firebase upload failed for chart ${i + 1}:', error);
            // Keep the original URL if upload fails
            firebaseUrls.push(chartPreviews[i]);
          }
        }
        console.log('ðŸ“Š All charts processed. Success rate:', 
          `${firebaseUrls.filter(url => url.includes('firebasestorage')).length}/${chartPreviews.length}`
        );

        // Use Firebase URLs if available, otherwise use original previews
        const finalChartUrls = firebaseUrls;

        // Save analysis data to Firebase
        console.log('Saving analysis data to Firebase:', {
          analysisLength: finalAnalysisResults[0]?.analysis.length,
          timeframe: finalAnalysisResults[0]?.timeframe,
          chartCount: finalChartUrls.length,
          messageCount: messages.length
        });
        
        try {
          // If we already have a history ID, update the existing record
          if (historyId && auth.currentUser) {
            try {
              console.log('Updating existing history record with analysis:', historyId);
              
              const { ref, update } = await import('firebase/database');
              const historyRef = ref(database, `users/${auth.currentUser.uid}/history/${historyId}`);
              
              await update(historyRef, {
                type: 'market-analysis',
                title: finalAnalysisResults[0]?.timeframe ? `Market Analysis - ${finalAnalysisResults[0].timeframe}` : 'Market Analysis',
                content: finalAnalysisResults[0]?.analysis,
                chartUrls: finalChartUrls,
                messages: messages.map(msg => ({
                  role: msg.role,
                  content: msg.content
                })),
                timestamp: Date.now()
              });
              
              console.log('Existing history record updated with analysis');
            } catch (error) {
              console.error('Error updating history with analysis:', error);
            }
          }
          // Otherwise create a new history record
          else if (auth.currentUser) {
            const savedAnalysisId = await saveChatAnalysis(auth.currentUser.uid, {
              analysis: finalAnalysisResults[0]?.analysis,
              messages: messages.map(msg => ({
                role: msg.role,
                content: msg.content
              })),
              timeframe: finalAnalysisResults[0]?.timeframe,
              chartUrls: finalChartUrls,
              timestamp: Date.now()
            });
            
            // Store the analysis ID for future use
            if (savedAnalysisId) {
              setHistoryId(savedAnalysisId);
              console.log('New history record created with ID:', savedAnalysisId);
            }
          }
          console.log('All analyses saved successfully');
        } catch (err) {
          console.error('Error saving analysis:', err);
        }
      }
      console.log('Process complete.');
    } catch (error) {
      console.error('Analysis failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      handleError(errorMessage);
    } finally {
      setIsAnalyzing(false);
    }
  };

  const handlePreviousAnalysis = () => {
    if (currentAnalysisIndex > 0) {
      const newIndex = currentAnalysisIndex - 1;
      setCurrentAnalysisIndex(newIndex);
      setAnalysis(analysisResults[newIndex].analysis);
    }
  };

  const handleNextAnalysis = () => {
    if (currentAnalysisIndex < analysisResults.length - 1) {
      const newIndex = currentAnalysisIndex + 1;
      setCurrentAnalysisIndex(newIndex);
      setAnalysis(analysisResults[newIndex].analysis);
    }
  };

  const handleClearAnalysis = () => {
    // Clear analysis and messages
    setAnalysis('');
    setMessages([{
      role: 'assistant',
      content: 'Starting new Analysis session\n\n' + initialMessage
    }]);
    setError(null);
    
    // Clear all image related state
    setImage(null);
    setPendingImages([]);
    setChartPreviews([]);
    setAnalysisResults([]);
    setCurrentAnalysisIndex(0);
    
    // Reset UI states
    setShowUploadPrompt(false);
    setShowUploader(false);
    setShowChartGenerator(false);
    
    // Reset history ID to ensure a new record is created for the next analysis
    resetHistoryId();
    
    // Clean up any object URLs to prevent memory leaks
    chartPreviews.forEach(url => {
      if (url.startsWith('blob:')) {
        URL.revokeObjectURL(url);
      }
    });
  };

  const handleNewConversation = () => {
    // Clear all current state
    handleClearAnalysis();
    
    // Reset chat-specific state
    setMessages([{ role: 'assistant', content: initialMessage }]);
    setInputMessage('');
    setIsLoading(false);
    setChatHistory([]);
    
    // Reset analysis type to default
    setAnalysisType(AnalysisType.Technical);
    
    // Reset selected model to default
    setSelectedModel('anthropic/claude-3-opus:beta');
    
    // Reset history ID
    resetHistoryId();
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    // Send message when Enter is pressed without Shift key
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (inputMessage.trim()) {
        handleSendMessage();
      }
    }
  };

  const handleSendMessage = async () => {
    if (!inputMessage.trim()) return;
    
    const userMessage = inputMessage.trim();
    setInputMessage('');
    
    // Add user message to chat
    setMessages(prev => [...prev, { role: 'user', content: userMessage }]);
    
    // Start loading state
    setIsLoading(true);
    
    try {
      // Add assistant typing indicator
      setMessages(prev => [...prev, { role: 'assistant', content: '', isTyping: true }]);
      
      // Send message to API - filter out any analysis messages to avoid confusion
      const messagesToSend = messages
        .filter(msg => msg.content !== analysis)
        .concat([{ role: 'user', content: userMessage }]);
      
      const response = await sendChatMessage(
        messagesToSend,
        selectedModel,
        analysis,
        analysisType
      );
      
      // Update chat history
      setChatHistory(prev => [...prev, userMessage, response]);
      
      // Remove typing indicator and add actual response
      const updatedMessages = [
        ...messages.filter(msg => !msg.isTyping),
        { role: 'user', content: userMessage },
        { role: 'assistant', content: response }
      ];
      
      setMessages(updatedMessages);
      
      // Save the updated chat history if a user is logged in
      if (auth.currentUser) {
        try {
          console.log('Preparing to save chat messages to Firebase:', {
            messageCount: updatedMessages.length,
            hasAnalysis: !!analysis,
            hasHistoryId: !!historyId
          });
          
          // Ensure messages are properly formatted for Firebase
          const cleanMessages = updatedMessages.map(msg => ({
            role: msg.role,
            content: msg.content,
            ...(msg.isTyping ? { isTyping: msg.isTyping } : {})
          }));
          
          // Import Firebase functions
          const { ref, update, push, set } = await import('firebase/database');
          
          // If we have an existing history ID, update it
          if (historyId) {
            console.log('Updating existing chat history with ID:', historyId);
            
            const historyRef = ref(database, `users/${auth.currentUser.uid}/history/${historyId}`);
            
            await update(historyRef, {
              messages: cleanMessages,
              lastUpdated: Date.now()
            });
            
            console.log('Existing chat history updated successfully');
          } 
          // If we don't have a history ID yet, create a new one
          else {
            console.log('Creating new history record for chat');
            
            // Create a new entry
            const newHistoryRef = push(ref(database, `users/${auth.currentUser.uid}/history`));
            
            await set(newHistoryRef, {
              type: 'chat-conversation',
              title: `Chat - ${new Date().toLocaleDateString()}`,
              content: cleanMessages[cleanMessages.length - 1].content,
              messages: cleanMessages,
              timestamp: Date.now(),
              id: newHistoryRef.key
            });
            
            // Store the new history ID
            if (newHistoryRef.key) {
              setHistoryId(newHistoryRef.key);
              console.log('New history record created with ID:', newHistoryRef.key);
            }
          }
        } catch (error) {
          console.error('Error saving chat history:', error);
        }
      }
    } catch (err) {
      console.error('Error sending message:', err);
      // Remove typing indicator and add error message
      setMessages(prev => [
        ...prev.filter(msg => !msg.isTyping),
        { role: 'assistant', content: 'Sorry, there was an error processing your message. Please try again.' }
      ]);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (location.state?.analysisId && auth.currentUser) {
      console.log('Loading analysis history with ID:', location.state.analysisId);
      
      setHistoryId(location.state.analysisId);
      
      const loadAnalysisHistory = async () => {
        try {
          const { ref, get } = await import('firebase/database');
          const historyRef = ref(database, `users/${auth.currentUser?.uid}/history/${location.state.analysisId}`);
          const snapshot = await get(historyRef);
          
          if (snapshot.exists()) {
            const historyData = snapshot.val();
            console.log('Loaded analysis history:', {
              id: historyData.id,
              type: historyData.type,
              title: historyData.title,
              contentLength: historyData.content?.length || 0,
              hasMessages: !!historyData.messages,
              messageCount: historyData.messages?.length || 0
            });
            
            // Clear all previous content first
            setAnalysis(null);
            setChartPreviews([]);
            setPendingImages([]);
            setTimeframe(null);
            
            if (historyData.type === 'market-analysis') {
              setAnalysis(historyData.content);
              setAnalysisType(historyData.analysisType || AnalysisType.Technical);
              
              // If there are chart URLs, set them as previews only for market-analysis
              if (historyData.chartUrls && historyData.chartUrls.length > 0) {
                setChartPreviews(historyData.chartUrls);
                setPendingImages(historyData.chartUrls);
              }
              
              // Set timeframe if available
              if (historyData.timeframe) {
                setTimeframe(historyData.timeframe);
              }
            } else if (historyData.type === 'chat-conversation') {
              // For chat conversations, analysis remains null (cleared above)
              setAnalysisType(AnalysisType.Technical);
            }
            
            // Load saved messages if they exist
            if (historyData.messages && Array.isArray(historyData.messages) && historyData.messages.length > 0) {
              console.log('Loading saved chat messages:', {
                count: historyData.messages.length,
                sample: historyData.messages.slice(0, 2)
              });
              
              // Ensure messages have the correct format
              const validMessages = historyData.messages.map(msg => ({
                role: msg.role === 'user' || msg.role === 'assistant' ? msg.role : 'assistant',
                content: msg.content || '',
                ...(msg.isTyping ? { isTyping: msg.isTyping } : {})
              }));
              
              setMessages(validMessages);
            } else {
              // If no messages, initialize with default assistant message
              console.log('No saved messages found, initializing with default message');
              setMessages([{
                role: 'assistant',
                content: `I have analyzed this chart. You can ask me questions such as:\n` +
                  'â€¢ Can you explain the key support and resistance levels in more detail?\n' +
                  'â€¢ What are the main technical indicators suggesting?\n' +
                  'â€¢ What is the recommended position size and risk management?\n' +
                  'â€¢ Can you provide more details about the market structure?\n' +
                  'â€¢ What are the potential entry and exit points?'
              }]);
            }
            
            // If there are chart URLs, set them as previews
            if (historyData.chartUrls && historyData.chartUrls.length > 0) {
              setChartPreviews(historyData.chartUrls);
              setPendingImages(historyData.chartUrls);
            }
          }
        } catch (error) {
          console.error('Error loading analysis history:', error);
        } finally {
          // Clear the location state to prevent re-initializing on page refresh
          window.history.replaceState({}, document.title);
        }
      };
      
      loadAnalysisHistory();
    }
  }, [location.state?.analysisId, auth.currentUser, database]);

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4">
      <div className="max-w-7xl mx-auto flex flex-col md:flex-row gap-4">
        {/* Left side - Image Upload and Analysis Area */}
        <div className="flex-1 space-y-4">
          {/* Upload/Generate Options */}
          <div className="glass-effect rounded-lg p-4">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-lg font-medium text-white">Upload Chart</h3>
              <div className="flex items-center gap-2">
                {/* <button
                  onClick={() => {
                    handleCloseUpload();
                    handleUploadMore();
                  }}
                  className="flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 rounded-md transition-colors"
                  title="Switch to Generate Chart"
                >
                  Upload Another Chart
                </button> */}
                <button
                  onClick={handleCloseUpload}
                  className="p-1 hover:bg-gray-700 rounded-full transition-colors"
                >
                  <X className="w-5 h-5 text-gray-400" />
                </button>
              </div>
            </div>
            <div className="flex items-center justify-center w-full">
              <div
                className="flex flex-col items-center justify-center w-full h-64 border-2 border-gray-600 border-dashed rounded-lg cursor-pointer bg-gray-800 hover:bg-gray-700"
                onDrop={handleDrop}
                onDragOver={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                }}
                onClick={() => fileInputRef.current?.click()}
              >
                <input
                  type="file"
                  ref={fileInputRef}
                  onChange={handleFileSelect}
                  accept="image/*"
                  multiple
                  className="hidden"
                  id="file-upload"
                />
                <div className="flex flex-col items-center justify-center pt-5 pb-6">
                  <svg className="w-8 h-8 mb-4 text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 16">
                    <path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"/>
                  </svg>
                  <p className="mb-2 text-sm text-gray-400"><span className="font-semibold">Click to upload</span> or drag and drop</p>
                  <p className="text-xs text-gray-400">PNG, JPG or GIF</p>
                </div>
              </div>
            </div>
          </div>

          {/* Chart Previews Section */}
          {pendingImages.length > 0 && (
            <div className="glass-effect rounded-lg p-3">
              <div className="flex justify-between items-center mb-3">
                <h3 className="text-lg font-medium text-white">Chart Previews</h3>
                <button
                  onClick={handleFinishUploading}
                  className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors font-medium"
                  disabled={isAnalyzing}
                >
                  {isAnalyzing ? (
                    <div className="flex items-center">
                      <span className="mr-2">Analyzing...</span>
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
                    </div>
                  ) : (
                    'Analyze 1'
                  )}
                </button>
              </div>
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                {pendingImages.map((url, index) => (
                  <div 
                    key={index} 
                    className="relative group cursor-pointer"
                    onClick={() => setSelectedPreviewUrl(url)}
                  >
                    <img 
                      src={url} 
                      alt={`Chart ${index + 1}`} 
                      className="w-full h-48 object-cover rounded-lg border border-gray-700"
                    />
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRemoveImage(index);
                      }}
                      className="absolute top-2 right-2 p-1 bg-red-600 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                      <X size={16} />
                    </button>
                  </div>
                ))}
              </div>
             
            </div>
          )}

          {/* Analysis Results */}
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-lg font-medium text-white">Analysis Results</h3>
            <button
              onClick={handleClearAnalysis}
              className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors font-medium"
            >
              Clear Analysis
            </button>
          </div>
          <div className="glass-effect rounded-lg p-4 min-h-[400px] overflow-y-auto">
            {error ? (
              <div className="flex items-start space-x-2 text-red-400">
                <AlertCircle className="w-5 h-5 mt-0.5 flex-shrink-0" />
                <pre className="whitespace-pre-wrap font-mono text-sm">{error}</pre>
              </div>
            ) : isAnalyzing ? (
              <div className="flex flex-col items-center justify-center space-y-4 text-gray-300 h-full">
                <Loader2 className="w-8 h-8 animate-spin text-indigo-400" />
                <div className="text-lg font-medium">Analyzing chart {currentChart}/{totalCharts}</div>
                <div className="text-sm text-gray-400">This may take a few moments</div>
              </div>
            ) : analysis ? (
              <div className="bg-gray-900/50 rounded-lg p-8 mb-6">
                {/* Header Section */}
                <div className="pb-6">
                  <div className="flex items-center justify-between mb-6">
                    <h2 className="text-3xl font-bold text-white">AI Chart Analyzer</h2>
                    
                    {/* Pagination controls */}
                    {analysisResults.length > 1 && (
                      <div className="flex items-center gap-2">
                        <button 
                          onClick={handlePreviousAnalysis}
                          disabled={currentAnalysisIndex === 0}
                          className={`p-1 rounded-full ${currentAnalysisIndex === 0 ? 'text-gray-600' : 'text-gray-300 hover:bg-gray-700'}`}
                        >
                          <ChevronLeft className="w-6 h-6" />
                        </button>
                        <span className="text-sm text-gray-300">
                          {currentAnalysisIndex + 1} / {analysisResults.length}
                        </span>
                        <button 
                          onClick={handleNextAnalysis}
                          disabled={currentAnalysisIndex === analysisResults.length - 1}
                          className={`p-1 rounded-full ${currentAnalysisIndex === analysisResults.length - 1 ? 'text-gray-600' : 'text-gray-300 hover:bg-gray-700'}`}
                        >
                          <ChevronRight className="w-6 h-6" />
                        </button>
                      </div>
                    )}
                  </div>
                  <div className="">
                    <ul className="space-y-2 text-gray-300">
                      {timeframe && (
                        <li className="flex items-center gap-3">
                          <span className="w-2 h-2 bg-indigo-400 rounded-full"></span>
                          <span className="font-medium text-indigo-200"><strong>Timeframe:</strong></span>
                          <span className="text-gray-200">{analysisResults.length > 0 ? analysisResults[currentAnalysisIndex].timeframe : timeframe}</span>
                        </li>
                      )}
                    </ul>
                  </div>
                </div>

                {/* Analysis Content */}
                <div className="space-y-6 relative">
                  <Markdown 
                    className={styles.markdownContent}
                    components={{
                      h1: ({node, ...props}) => (
                        <h1 className={styles.markdownH1} {...props} />
                      ),
                      h2: ({node, ...props}) => (
                        <h2 className={styles.markdownH2} {...props} />
                      ),
                      ul: ({node, ...props}) => (
                        <ul className={styles.markdownUl} {...props} />
                      ),
                      li: ({node, ...props}) => (
                        <li className={styles.markdownLi} {...props} />
                      ),
                      strong: ({node, ...props}) => (
                        <strong className={styles.markdownStrong} {...props} />
                      ),
                      p: ({node, ...props}) => (
                        <p className={styles.markdownP} {...props} />
                      )
                    }}
                  >
                    {analysis}
                  </Markdown>

                  {/* Add confidence bar at the bottom if confidence level is found */}
                  {analysis && (() => {
                    const match = analysis.match(/confidence level:?\s*(\d+)%/i);
                    if (match) {
                      const percentage = parseInt(match[1]);
                      
                      // Determine color based on confidence level
                      const getConfidenceColor = (value: number) => {
                        if (value >= 80) return 'bg-green-500';
                        if (value >= 60) return 'bg-yellow-500';
                        if (value >= 40) return 'bg-orange-500';
                        return 'bg-red-500';
                      };
                      
                      return (
                        <div className="mt-6 bg-gray-800 p-4 rounded-lg">
                          <div className="text-sm font-medium text-gray-300 mb-2">Analysis Confidence</div>
                          <div className="flex items-center gap-2">
                            <div className="flex-1 bg-gray-700 rounded-full h-3 overflow-hidden">
                              <div 
                                className={`h-3 rounded-full transition-all duration-500 ${getConfidenceColor(percentage)}`}
                                style={{ width: `${percentage}%` }}
                              />
                            </div>
                            <span className="text-sm font-medium text-gray-300 min-w-[3rem]">
                              {percentage}%
                            </span>
                          </div>
                        </div>
                      );
                    }
                    return null;
                  })()}
                </div>
              </div>
            ) : (
              <div className="text-gray-400 text-center">
                Upload a chart image to see the analysis here
              </div>
            )}
          </div>
        </div>

        {/* Right side - Chat Interface */}
        <div className="w-full md:w-[500px] shrink-0">
          <div className="glass-effect rounded-lg p-4 h-[600px]">
            <div className="flex flex-col h-full">
              {/* Header with Model Selection */}
              <div className="mb-2">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center gap-4">
                    <div className="flex items-center gap-2">
                      <MessageSquare className="w-5 h-5 text-indigo-400" />
                      <h2 className="text-lg font-medium text-white">AI Analysis Chat</h2>
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-sm text-gray-400">
                      Selected Model: <span className="text-indigo-400 font-medium">{AVAILABLE_MODELS.find(m => m.id === selectedModel)?.name || selectedModel}</span>
                      {AVAILABLE_MODELS.find(m => m.id === selectedModel)?.premium ? 
                        <span className="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-indigo-100 text-indigo-800">Premium</span> : 
                        <span className="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-800">Free</span>
                      }
                      {AVAILABLE_MODELS.find(m => m.id === selectedModel)?.beta && 
                        <span className="ml-2 inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">Beta</span>
                      }
                    </span>
                  </div>
                </div>
                <div className="mb-4">
                  <select 
                    value={selectedModel} 
                    onChange={(e) => {
                      const newModel = e.target.value as ModelId;
                      
                      // Save current state for the current model
                      setModelConversations(prev => ({
                        ...prev,
                        [selectedModel]: {
                          messages,
                          analysis,
                          chartPreviews
                        }
                      }));
                      
                      // Update the selected model
                      setSelectedModel(newModel);
                      
                      // Switch to the history ID for the new model if it exists
                      if (modelHistoryIds[newModel]) {
                        setHistoryId(modelHistoryIds[newModel]);
                      } else {
                        // Reset history ID for new model conversation
                        setHistoryId(null);
                      }
                      
                      // Restore state for the new model if it exists
                      if (modelConversations[newModel]) {
                        setMessages(modelConversations[newModel].messages);
                        setAnalysis(modelConversations[newModel].analysis);
                        setChartPreviews(modelConversations[newModel].chartPreviews);
                      } else {
                        // Initialize with default state for new model
                        setMessages([{
                          role: 'assistant',
                          content: initialMessage
                        }]);
                        setAnalysis('');
                        setChartPreviews([]);
                      }
                    }}
                    className="w-full p-2 text-sm bg-gray-800 border border-gray-700 rounded text-white"
                  >
                    <optgroup label="Premium Models">
                      {premiumModels.map(model => (
                        <option key={model.id} value={model.id}>
                          {model.name} {model.creditCost > 0 && `(${model.creditCost}x credit)`} {model.beta && 'â€¢ Beta'}
                        </option>
                      ))}
                    </optgroup>
                    <optgroup label="Non-Premium Models">
                      {nonPremiumModels.map(model => (
                        <option key={model.id} value={model.id}>
                          {model.name} {model.creditCost > 0 && `(${model.creditCost}x credit)`} {model.beta && 'â€¢ Beta'}
                        </option>
                      ))}
                    </optgroup>
                  </select>
                </div>
                
                <span className="text-sm text-gray-400 mb-2 block">
                  Selected Analysis Type: <span className="text-indigo-400 font-medium">{analysisType}</span>
                </span>
                <div className="flex gap-1.5">
                  {Object.values(AnalysisType).map((type) => (
                    <button
                      key={type}
                      type="button"
                      onClick={() => {
                        setAnalysisType(type);
                        console.log('Analysis type changed to:', type);
                      }}
                      className={`relative px-2.5 py-1 rounded-lg text-sm font-medium transition-colors flex-1 cursor-pointer
                        ${analysisType === type
                          ? 'bg-indigo-600 text-white'
                          : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                        }`}
                    >
                      <span className="relative z-10">
                        {type === 'Technical' && 'ðŸ“Š'}
                        {type === 'Fundamental' && 'ðŸ“ˆ'}
                        {type === 'Combined' && 'ðŸ”„'}
                        {' ' + type}
                      </span>
                    </button>
                  ))}
                </div>
              </div>

              {/* Chat Messages Area */}
              <div className="flex-1 overflow-y-auto mb-3 space-y-2 min-h-0 bg-gray-900">
                {messages.length === 1 && messages[0].content === initialMessage && (
                  <ChatMessage message={messages[0]} isLoading={isLoading} />
                )}
                
                {!(messages.length === 1 && messages[0].content === initialMessage) && (
                  <div className="space-y-4">
                    {messages.map((message, index) => (
                      <ChatMessage key={index} message={message} isLoading={isLoading} isCurrent={index === messages.length - 1 && message.role === 'assistant'} />
                    ))}
                  </div>
                )}

                {error && (
                  <div className="text-red-500 mt-4">
                    Error: {error}
                  </div>
                )}

                {isAnalyzing && (
                  <div className="flex items-center text-blue-400 mt-4">
                    <span className="mr-2">Analyzing chart {currentChart}/{totalCharts}</span>
                    <div className="animate-bounce">.</div>
                    <div className="animate-bounce animation-delay-200">.</div>
                    <div className="animate-bounce animation-delay-400">.</div>
                  </div>
                )}
                
              </div>

              {/* Input Area */}
              <div className="mt-auto">
                <div className="flex flex-col">
                  <button
                    onClick={handleNewConversation}
                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors font-medium mb-2"
                  >
                    + New Conversation
                  </button>
                  <div className="flex items-center">
                    <textarea
                      value={inputMessage}
                      onChange={(e) => setInputMessage(e.target.value)}
                      onKeyDown={handleKeyDown}
                      placeholder="Type your message..."
                      className={`${styles.chatTextarea} flex-1 bg-gray-800 border border-gray-700 rounded-lg px-3 py-2 text-sm text-white placeholder-gray-500 focus:outline-none focus:border-indigo-500 mr-2`}
                    />
                    <button
                      onClick={handleSendMessage}
                      disabled={!inputMessage.trim()}
                      className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors font-medium mt-0.5"
                    >
                      <Send className="w-5 h-5" />
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Upload Confirmation Modal */}
      {showUploadPrompt && (
        <UploadConfirmationModal
          onClose={handleCloseUpload}
          onUploadMore={handleUploadMore}
          onAnalyze={handleFinishUploading}
          charts={pendingImages}
          isAnalyzing={isAnalyzing}
        />
      )}
      {selectedPreviewUrl && (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
          <div className="bg-gray-900 p-6 rounded-lg shadow-xl max-w-4xl w-full mx-4 relative">
            {/* Close button */}
            <button
              onClick={() => setSelectedPreviewUrl(null)}
              className="absolute top-2 right-2 text-gray-400 hover:text-white transition-colors"
              aria-label="Close chart preview"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
            
            <h2 className="text-xl font-semibold mb-4 text-white">Chart Preview</h2>
            <img 
              src={selectedPreviewUrl} 
              alt="Chart preview" 
              className="w-full rounded-lg"
            />
          </div>
        </div>
      )}
    </div>
  );
}

export default AIAnalysisChat;
